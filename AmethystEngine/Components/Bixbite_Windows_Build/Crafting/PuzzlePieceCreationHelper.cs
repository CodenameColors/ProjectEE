using System;
using System.Collections.Generic;
using BixBite.Combat;
using BixBite.Crafting.HexGrid;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace BixBite.Crafting
{
	/// <summary>
	/// This class holds ALL the puzzle piece creation code.
	/// This code is AUTOGENERATED from my external tool "PuzzlePieceCodeGenerator"
	/// Don't modify this code unless it's code from THAT tool. Thanks :D
	/// </summary>
	public partial class PuzzlePiece
	{


		// I made methods for ALL the piece types... because i don't wanna go through thousands of lines of code later to find one piece.

		#region puzzle piece creation methods.

		private void CreatePuzzlePiece_0(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 6;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "0"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_1(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 2;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "1"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_2(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 3;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "2"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_3(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 4;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "3"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_4(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 4;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "4"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_5(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 3;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "5"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_6(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 4;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "6"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_7(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 3;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "7"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_8(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 5;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "8"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_9(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 8;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "9"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, -30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[6]);
			InternalCells[6].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[7]);
			InternalCells[7].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[6]);
			InternalCells[6].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_10(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 6;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "10"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_11(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 5;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "11"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_12(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 7;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "12"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_13(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 5;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "13"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 180.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 240.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_14(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 7;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "14"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 180.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 240.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 150.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_15(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 9;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "15"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 120.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[8]);
			InternalCells[8].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetEast(InternalCells[7]);
			InternalCells[7].SetWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[5]);
			InternalCells[5].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetEast(InternalCells[8]);
			InternalCells[8].SetWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetWest(InternalCells[6]);
			InternalCells[6].SetEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetWest(InternalCells[7]);
			InternalCells[7].SetEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_16(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 12;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "16"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 150.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, -30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 150.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 9, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 10, 60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 11, 120.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[7]);
			InternalCells[7].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetSouthWest(InternalCells[8]);
			InternalCells[8].SetNorthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetSouthEast(InternalCells[9]);
			InternalCells[9].SetNorthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthEast(InternalCells[6]);
			InternalCells[6].SetSouthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetSouthWest(InternalCells[11]);
			InternalCells[11].SetNorthEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetEast(InternalCells[10]);
			InternalCells[10].SetWest(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetNorthWest(InternalCells[7]);
			InternalCells[7].SetSouthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetEast(InternalCells[11]);
			InternalCells[11].SetWest(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetWest(InternalCells[9]);
			InternalCells[9].SetEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetNorthEast(InternalCells[8]);
			InternalCells[8].SetSouthWest(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetWest(InternalCells[10]);
			InternalCells[10].SetEast(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_17(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 7;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "17"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_18(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 7;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "18"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, -30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_19(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 9;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "19"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 120.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetSouthEast(InternalCells[8]);
			InternalCells[8].SetNorthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[5]);
			InternalCells[5].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthWest(InternalCells[6]);
			InternalCells[6].SetSouthEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_20(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 9;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "20"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 120.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[7]);
			InternalCells[7].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthWest(InternalCells[6]);
			InternalCells[6].SetNorthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthEast(InternalCells[5]);
			InternalCells[5].SetSouthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetEast(InternalCells[7]);
			InternalCells[7].SetWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetEast(InternalCells[8]);
			InternalCells[8].SetWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetWest(InternalCells[6]);
			InternalCells[6].SetEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetWest(InternalCells[7]);
			InternalCells[7].SetEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_21(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 11;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "21"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 180.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 240.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 150.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 9, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 10, 240.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[8]);
			InternalCells[8].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[9]);
			InternalCells[9].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthWest(InternalCells[8]);
			InternalCells[8].SetNorthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetEast(InternalCells[7]);
			InternalCells[7].SetWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetEast(InternalCells[8]);
			InternalCells[8].SetWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetWest(InternalCells[6]);
			InternalCells[6].SetEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthEast(InternalCells[5]);
			InternalCells[5].SetSouthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetEast(InternalCells[9]);
			InternalCells[9].SetWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetWest(InternalCells[7]);
			InternalCells[7].SetEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetEast(InternalCells[10]);
			InternalCells[10].SetWest(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetWest(InternalCells[8]);
			InternalCells[8].SetEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetWest(InternalCells[9]);
			InternalCells[9].SetEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_22(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 9;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "22"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, -60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, -90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, -30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[8]);
			InternalCells[8].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetEast(InternalCells[7]);
			InternalCells[7].SetWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetEast(InternalCells[8]);
			InternalCells[8].SetWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetWest(InternalCells[6]);
			InternalCells[6].SetEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetWest(InternalCells[7]);
			InternalCells[7].SetEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_23(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 4;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "23"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[1]);
			InternalCells[1].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_24(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 5;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "24"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[1]);
			InternalCells[1].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_25(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 8;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "25"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 150.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 210.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[1]);
			InternalCells[1].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[6]);
			InternalCells[6].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetSouthEast(InternalCells[7]);
			InternalCells[7].SetNorthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthWest(InternalCells[6]);
			InternalCells[6].SetSouthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_26(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 4;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "26"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 180.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_27(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 6;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "27"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[1]);
			InternalCells[1].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[3]);
			InternalCells[3].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_28(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 11;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "28"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 210.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 150.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 9, 60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 10, 120.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthWest(InternalCells[1]);
			InternalCells[1].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthWest(InternalCells[6]);
			InternalCells[6].SetNorthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthEast(InternalCells[7]);
			InternalCells[7].SetNorthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthEast(InternalCells[2]);
			InternalCells[2].SetSouthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[6]);
			InternalCells[6].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetSouthWest(InternalCells[10]);
			InternalCells[10].SetNorthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthWest(InternalCells[5]);
			InternalCells[5].SetSouthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetEast(InternalCells[9]);
			InternalCells[9].SetWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetEast(InternalCells[10]);
			InternalCells[10].SetWest(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetWest(InternalCells[8]);
			InternalCells[8].SetEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetNorthEast(InternalCells[7]);
			InternalCells[7].SetSouthWest(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetWest(InternalCells[9]);
			InternalCells[9].SetEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_29(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 15;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "29"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 180.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 90.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 150.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, -30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 9, 90.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 10, 210.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 11, -60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 12, 60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 13, 180.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 14, 90.0f * ScaleX, 225.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthEast(InternalCells[2]);
			InternalCells[2].SetNorthWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthWest(InternalCells[4]);
			InternalCells[4].SetNorthEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetEast(InternalCells[3]);
			InternalCells[3].SetWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthWest(InternalCells[0]);
			InternalCells[0].SetSouthEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetEast(InternalCells[4]);
			InternalCells[4].SetWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetWest(InternalCells[2]);
			InternalCells[2].SetEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthEast(InternalCells[1]);
			InternalCells[1].SetSouthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[6]);
			InternalCells[6].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[5]);
			InternalCells[5].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetWest(InternalCells[3]);
			InternalCells[3].SetEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthWest(InternalCells[9]);
			InternalCells[9].SetNorthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetSouthEast(InternalCells[10]);
			InternalCells[10].SetNorthWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetEast(InternalCells[8]);
			InternalCells[8].SetWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetSouthWest(InternalCells[11]);
			InternalCells[11].SetNorthEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetEast(InternalCells[9]);
			InternalCells[9].SetWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetSouthEast(InternalCells[12]);
			InternalCells[12].SetNorthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetWest(InternalCells[7]);
			InternalCells[7].SetEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetNorthEast(InternalCells[5]);
			InternalCells[5].SetSouthWest(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetSouthWest(InternalCells[12]);
			InternalCells[12].SetNorthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetWest(InternalCells[8]);
			InternalCells[8].SetEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetSouthWest(InternalCells[13]);
			InternalCells[13].SetNorthEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetNorthWest(InternalCells[6]);
			InternalCells[6].SetSouthEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetNorthEast(InternalCells[7]);
			InternalCells[7].SetSouthWest(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[12].SetNorthEast(InternalCells[9]);
			InternalCells[9].SetSouthWest(InternalCells[12]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[12].SetSouthEast(InternalCells[14]);
			InternalCells[14].SetNorthWest(InternalCells[12]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[12].SetNorthWest(InternalCells[8]);
			InternalCells[8].SetSouthEast(InternalCells[12]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[13].SetNorthEast(InternalCells[10]);
			InternalCells[10].SetSouthWest(InternalCells[13]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[14].SetNorthWest(InternalCells[12]);
			InternalCells[12].SetSouthEast(InternalCells[14]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_30(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 12;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "30"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 180.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, -30.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 210.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, -30.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 9, 210.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 10, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 11, 180.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetSouthWest(InternalCells[2]);
			InternalCells[2].SetNorthEast(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetSouthEast(InternalCells[3]);
			InternalCells[3].SetNorthWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetNorthEast(InternalCells[0]);
			InternalCells[0].SetSouthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthWest(InternalCells[7]);
			InternalCells[7].SetNorthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetNorthWest(InternalCells[1]);
			InternalCells[1].SetSouthEast(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetEast(InternalCells[5]);
			InternalCells[5].SetWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[8]);
			InternalCells[8].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetEast(InternalCells[6]);
			InternalCells[6].SetWest(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetWest(InternalCells[4]);
			InternalCells[4].SetEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetEast(InternalCells[7]);
			InternalCells[7].SetWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetWest(InternalCells[5]);
			InternalCells[5].SetEast(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetNorthEast(InternalCells[3]);
			InternalCells[3].SetSouthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetSouthEast(InternalCells[9]);
			InternalCells[9].SetNorthWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetWest(InternalCells[6]);
			InternalCells[6].SetEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetSouthEast(InternalCells[10]);
			InternalCells[10].SetNorthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetSouthWest(InternalCells[11]);
			InternalCells[11].SetNorthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetNorthWest(InternalCells[7]);
			InternalCells[7].SetSouthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetNorthWest(InternalCells[8]);
			InternalCells[8].SetSouthEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetNorthEast(InternalCells[9]);
			InternalCells[9].SetSouthWest(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		private void CreatePuzzlePiece_31(int maxHexCells, int mixedHexCells, Color fillColor, Texture2D fillTexture,
			EMagicType desiredMagicType, float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> cellToCopy = null)
		{
			maxHexCells = 17;
			mixedHexCells = (int) (maxHexCells * homogenousPercent);
			// Is this the first time we need to create this puzzle piece?
			if (cellToCopy == null)
			{
				#region create the hex cells

				CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Creating piece {0} for the first time!", "31"));
				InternalCells.Add(new PuzzlePieceHexCell(
						this, 0, 0.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 1, 60.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 2, 120.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 3, 240.0f * ScaleX, 0.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 4, 150.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 5, 270.0f * ScaleX, 45.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 6, 0.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 7, 60.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 8, 120.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 9, 180.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 10, 240.0f * ScaleX, 90.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 11, 150.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 12, 270.0f * ScaleX, 135.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 13, 0.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 14, 60.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 15, 120.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);

				InternalCells.Add(new PuzzlePieceHexCell(
						this, 16, 240.0f * ScaleX, 180.0f * ScaleY, _cellWidth, _cellHeight, null,
						null, fillTexture, fillTexture, spriteFont)
					{FillColor = fillColor, OnClickHook = OnHexCellEvent, MagicType = desiredMagicType});

				// TODO: This will need to be changed per cell (the above cell as not all are homogenous)
				this.ElementalCellCounts_S.AddElementalValue(desiredMagicType);


			}

			#endregion

			// Let's Generate all the required Connections.

			InternalCells[0].SetEast(InternalCells[1]);
			InternalCells[1].SetWest(InternalCells[0]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetEast(InternalCells[2]);
			InternalCells[2].SetWest(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[1].SetWest(InternalCells[0]);
			InternalCells[0].SetEast(InternalCells[1]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetSouthEast(InternalCells[4]);
			InternalCells[4].SetNorthWest(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[2].SetWest(InternalCells[1]);
			InternalCells[1].SetEast(InternalCells[2]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[3].SetSouthEast(InternalCells[5]);
			InternalCells[5].SetNorthWest(InternalCells[3]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthEast(InternalCells[9]);
			InternalCells[9].SetNorthWest(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetSouthWest(InternalCells[8]);
			InternalCells[8].SetNorthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[4].SetNorthWest(InternalCells[2]);
			InternalCells[2].SetSouthEast(InternalCells[4]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetSouthWest(InternalCells[10]);
			InternalCells[10].SetNorthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[5].SetNorthWest(InternalCells[3]);
			InternalCells[3].SetSouthEast(InternalCells[5]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[6].SetEast(InternalCells[7]);
			InternalCells[7].SetWest(InternalCells[6]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetEast(InternalCells[8]);
			InternalCells[8].SetWest(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[7].SetWest(InternalCells[6]);
			InternalCells[6].SetEast(InternalCells[7]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetNorthEast(InternalCells[4]);
			InternalCells[4].SetSouthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetEast(InternalCells[9]);
			InternalCells[9].SetWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetSouthEast(InternalCells[11]);
			InternalCells[11].SetNorthWest(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[8].SetWest(InternalCells[7]);
			InternalCells[7].SetEast(InternalCells[8]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetEast(InternalCells[10]);
			InternalCells[10].SetWest(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetSouthWest(InternalCells[11]);
			InternalCells[11].SetNorthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetWest(InternalCells[8]);
			InternalCells[8].SetEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[9].SetNorthWest(InternalCells[4]);
			InternalCells[4].SetSouthEast(InternalCells[9]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetNorthEast(InternalCells[5]);
			InternalCells[5].SetSouthWest(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetSouthEast(InternalCells[12]);
			InternalCells[12].SetNorthWest(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[10].SetWest(InternalCells[9]);
			InternalCells[9].SetEast(InternalCells[10]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetNorthEast(InternalCells[9]);
			InternalCells[9].SetSouthWest(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetSouthWest(InternalCells[15]);
			InternalCells[15].SetNorthEast(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[11].SetNorthWest(InternalCells[8]);
			InternalCells[8].SetSouthEast(InternalCells[11]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[12].SetSouthWest(InternalCells[16]);
			InternalCells[16].SetNorthEast(InternalCells[12]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[12].SetNorthWest(InternalCells[10]);
			InternalCells[10].SetSouthEast(InternalCells[12]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[13].SetEast(InternalCells[14]);
			InternalCells[14].SetWest(InternalCells[13]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[14].SetEast(InternalCells[15]);
			InternalCells[15].SetWest(InternalCells[14]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[14].SetWest(InternalCells[13]);
			InternalCells[13].SetEast(InternalCells[14]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[15].SetNorthEast(InternalCells[11]);
			InternalCells[11].SetSouthWest(InternalCells[15]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[15].SetWest(InternalCells[14]);
			InternalCells[14].SetEast(InternalCells[15]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);

			InternalCells[16].SetNorthEast(InternalCells[12]);
			InternalCells[12].SetSouthWest(InternalCells[16]);
			//TODO: this will need to check for homogenous percent later
			HomogenousConnectionCounts.AddElementalValue(desiredMagicType);
		}

		#endregion



		/// <summary>
		/// This method will set up the logic, and the display connections.
		/// </summary>
		/// <param name="desiredPiece">The piece we want to display/use.</param>
		public void CreatePuzzlePiece(int desiredPiece, Texture2D fillTexture, EMagicType desiredMagicType,
			float homogenousPercent = 1.0f, List<PuzzlePieceHexCell> interncell = null)
		{
			CraftingMinigame.DebugOutToConsole(String.Format("\t\t  Create hex cells needed for this puzzle piece"));
			//We need a color
			Color fillColor = CraftingMinigame.GetMagicColor(desiredMagicType);
			int maxHexCells = 0;
			int mixedHexCells = 0;

			//Quick fix... needs to be done better when all the pieces are created in the hard coding below...
			if (InternalCells != null)
			{
				foreach (var cell in InternalCells)
				{
					cell.FillColor = fillColor;
				}
			}

			if (desiredPiece == 0)
			{
				CreatePuzzlePiece_0(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 1)
			{
				CreatePuzzlePiece_1(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 2)
			{
				CreatePuzzlePiece_2(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 3)
			{
				CreatePuzzlePiece_3(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 4)
			{
				CreatePuzzlePiece_4(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 5)
			{
				CreatePuzzlePiece_5(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 6)
			{
				CreatePuzzlePiece_6(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 7)
			{
				CreatePuzzlePiece_7(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 8)
			{
				CreatePuzzlePiece_8(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 9)
			{
				CreatePuzzlePiece_9(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 10)
			{
				CreatePuzzlePiece_10(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 11)
			{
				CreatePuzzlePiece_11(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 12)
			{
				CreatePuzzlePiece_12(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 13)
			{
				CreatePuzzlePiece_13(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 14)
			{
				CreatePuzzlePiece_14(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 15)
			{
				CreatePuzzlePiece_15(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 16)
			{
				CreatePuzzlePiece_16(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 17)
			{
				CreatePuzzlePiece_17(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 18)
			{
				CreatePuzzlePiece_18(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 19)
			{
				CreatePuzzlePiece_19(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 20)
			{
				CreatePuzzlePiece_20(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 21)
			{
				CreatePuzzlePiece_21(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 22)
			{
				CreatePuzzlePiece_22(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 23)
			{
				CreatePuzzlePiece_23(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 24)
			{
				CreatePuzzlePiece_24(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 25)
			{
				CreatePuzzlePiece_25(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 26)
			{
				CreatePuzzlePiece_26(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 27)
			{
				CreatePuzzlePiece_27(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 28)
			{
				CreatePuzzlePiece_28(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 29)
			{
				CreatePuzzlePiece_29(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 30)
			{
				CreatePuzzlePiece_30(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
			else if (desiredPiece == 31)
			{
				CreatePuzzlePiece_31(maxHexCells, mixedHexCells, fillColor, fillTexture, desiredMagicType, homogenousPercent,
					interncell);
			}
		} // End of All Creation Method
	} // End of class
} // End of namespace
